<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Maze Game with Level Selector</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      background-color: #000;
      color: #FFF;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
    }
    canvas {
      border: 2px solid #FFF;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }
    #levelDisplay {
      font-size: 1.2em;
      color: #FFD700;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }
    #sizeSelector {
      background: #333;
      color: #FFF;
      padding: 8px;
      border: 1px solid #FFF;
      border-radius: 4px;
      font-family: 'Orbitron', sans-serif;
      cursor: pointer;
    }
    .sun-button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      background: #333;
      color: #FFF;
      border: 2px solid #FFA500;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-family: 'Orbitron', sans-serif;
      transition: all 0.3s ease;
    }
    .sun-button:hover {
      background: #444;
      box-shadow: 0 0 15px rgba(255, 165, 0, 0.5);
    }
    .sun-icon {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle, #FFD700, #FFA500);
      margin-right: 10px;
      box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
    }
    #joystick {
      position: relative;
      width: 200px;
      height: 200px;
      background: #333;
      border-radius: 50%;
      touch-action: none;
    }
    #joystick-handle {
      position: absolute;
      width: 60px;
      height: 60px;
      background: #FFF;
      border-radius: 50%;
      top: 70px;
      left: 70px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="levelDisplay">Levels Completed: 0</div>
  <button class="sun-button" onclick="window.location.href='index.html'">
    <span class="sun-icon"></span>
    Back to Starbase
  </button>
  <canvas id="mazeCanvas" width="400" height="400"></canvas>
  <div id="controls">
    <div class="size-control">
      <label for="sizeSelector">Select Maze Size:</label>
      <select id="sizeSelector">
        <option value="5">5x5</option>
        <option value="15">15x15</option>
        <option value="25">25x25</option>
      </select>
    </div>
    <div id="joystick">
      <div id="joystick-handle"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const sizeSelector = document.getElementById('sizeSelector');
    const levelDisplay = document.getElementById('levelDisplay');
    const joystick = document.getElementById('joystick');
    const joystickHandle = document.getElementById('joystick-handle');

    let mazeSize = parseInt(sizeSelector.value);
    let cellSize = 400 / mazeSize;
    let player = { row: 0, col: 0 };
    let levelCount = 0;
    let maze = [];
    let isJoystickActive = false;
    let joystickCenterX, joystickCenterY;
    let handleCenterX, handleCenterY;
    let currentDirection = null;
    let moveInterval = null; // Added to manage continuous movement

    function updateLevelDisplay() {
      levelDisplay.textContent = `Levels Completed: ${levelCount}`;
    }

    function generateMaze() {
      maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
      const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function carve(row, col) {
        maze[row][col] = 0;
        const dirs = shuffle([...directions]);
        for (let [dr, dc] of dirs) {
          const newRow = row + dr;
          const newCol = col + dc;
          if (
            newRow >= 0 && newRow < mazeSize &&
            newCol >= 0 && newCol < mazeSize &&
            maze[newRow][newCol] === 1
          ) {
            const wallRow = row + dr / 2;
            const wallCol = col + dc / 2;
            if (
              wallRow >= 0 && wallRow < mazeSize &&
              wallCol >= 0 && wallCol < mazeSize
            ) {
              maze[wallRow][wallCol] = 0;
            }
            carve(newRow, newCol);
          }
        }
      }

      carve(0, 0);
      maze[0][0] = 0;
      maze[mazeSize - 1][mazeSize - 1] = 0;
    }

    function drawBackground() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      for (let i = 0; i < 100; i++) {
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function drawMaze() {
      for (let row = 0; row < mazeSize; row++) {
        for (let col = 0; col < mazeSize; col++) {
          if (maze[row][col] === 1) {
            ctx.fillStyle = '#2F4F4F';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
          }
        }
      }
    }

    function drawGoal() {
      const goalRow = mazeSize - 1;
      const goalCol = mazeSize - 1;
      const x = goalCol * cellSize;
      const y = goalRow * cellSize;
      const cx = x + cellSize / 2;
      const bodyWidth = cellSize / 3;
      const bodyHeight = cellSize / 2;
      const triangleHeight = cellSize / 6;

      ctx.fillStyle = 'silver';
      ctx.fillRect(cx - bodyWidth / 2, y + cellSize / 4, bodyWidth, bodyHeight);
      ctx.beginPath();
      ctx.moveTo(cx, y + cellSize / 4 - triangleHeight);
      ctx.lineTo(cx - bodyWidth / 2, y + cellSize / 4);
      ctx.lineTo(cx + bodyWidth / 2, y + cellSize / 4);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'blue';
      const windowRadius = cellSize / 10;
      ctx.beginPath();
      ctx.arc(cx, y + cellSize / 2, windowRadius, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = 'gray';
      const engineWidth = bodyWidth / 3;
      const engineHeight = cellSize / 10;
      ctx.fillRect(cx - bodyWidth / 2, y + cellSize / 4 + bodyHeight, engineWidth, engineHeight);
      ctx.fillRect(cx + bodyWidth / 2 - engineWidth, y + cellSize / 4 + bodyHeight, engineWidth, engineHeight);
    }

    function drawPlayer() {
      const x = player.col * cellSize;
      const y = player.row * cellSize;
      const cx = x + cellSize / 2;
      const playerScale = 0.8;
      const scaledCellSize = cellSize * playerScale;
      const helmetRadius = scaledCellSize / 4;
      const bodyWidth = scaledCellSize / 2;
      const bodyHeight = scaledCellSize / 2;

      const helmetGradient = ctx.createRadialGradient(cx, y + helmetRadius, 0, cx, y + helmetRadius, helmetRadius);
      helmetGradient.addColorStop(0, '#FFFFFF');
      helmetGradient.addColorStop(1, '#E0E0E0');
      ctx.fillStyle = helmetGradient;
      ctx.beginPath();
      ctx.arc(cx, y + helmetRadius, helmetRadius, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(cx - helmetRadius/3, y + helmetRadius/2, helmetRadius/4, 0, 2 * Math.PI);
      ctx.fill();

      const visorGradient = ctx.createLinearGradient(cx - helmetRadius/2, y + helmetRadius, cx + helmetRadius/2, y + helmetRadius);
      visorGradient.addColorStop(0, '#1a1a1a');
      visorGradient.addColorStop(0.5, '#333333');
      visorGradient.addColorStop(1, '#1a1a1a');
      ctx.fillStyle = visorGradient;
      ctx.fillRect(cx - helmetRadius/2, y + helmetRadius, helmetRadius, helmetRadius/2);

      const bodyGradient = ctx.createLinearGradient(cx - bodyWidth/2, y + 2 * helmetRadius, cx + bodyWidth/2, y + 2 * helmetRadius + bodyHeight);
      bodyGradient.addColorStop(0, '#FFFFFF');
      bodyGradient.addColorStop(1, '#E0E0E0');
      ctx.fillStyle = bodyGradient;
      ctx.fillRect(cx - bodyWidth/2, y + 2 * helmetRadius, bodyWidth, bodyHeight);

      ctx.fillStyle = '#333333';
      ctx.fillRect(cx + bodyWidth/2 - bodyWidth/6, y + 2 * helmetRadius, bodyWidth/6, bodyHeight);

      const armGradient = ctx.createLinearGradient(cx - bodyWidth/2, y + 2 * helmetRadius + bodyHeight/4, cx - bodyWidth/2 - scaledCellSize/4, y + 2 * helmetRadius + bodyHeight/4);
      armGradient.addColorStop(0, '#FFFFFF');
      armGradient.addColorStop(1, '#E0E0E0');
      ctx.strokeStyle = armGradient;
      ctx.lineWidth = scaledCellSize/8;
      ctx.beginPath();
      ctx.moveTo(cx - bodyWidth/2, y + 2 * helmetRadius + bodyHeight/4);
      ctx.lineTo(cx - bodyWidth/2 - scaledCellSize/4, y + 2 * helmetRadius + bodyHeight/4);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + bodyWidth/2, y + 2 * helmetRadius + bodyHeight/4);
      ctx.lineTo(cx + bodyWidth/2 + scaledCellSize/4, y + 2 * helmetRadius + bodyHeight/4);
      ctx.stroke();

      const legGradient = ctx.createLinearGradient(cx - bodyWidth/4, y + 2 * helmetRadius + bodyHeight, cx - bodyWidth/4, y + 2 * helmetRadius + bodyHeight + scaledCellSize/4);
      legGradient.addColorStop(0, '#FFFFFF');
      legGradient.addColorStop(1, '#E0E0E0');
      ctx.strokeStyle = legGradient;
      ctx.beginPath();
      ctx.moveTo(cx - bodyWidth/4, y + 2 * helmetRadius + bodyHeight);
      ctx.lineTo(cx - bodyWidth/4, y + 2 * helmetRadius + bodyHeight + scaledCellSize/4);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx + bodyWidth/4, y + 2 * helmetRadius + bodyHeight);
      ctx.lineTo(cx + bodyWidth/4, y + 2 * helmetRadius + bodyHeight + scaledCellSize/4);
      ctx.stroke();

      ctx.fillStyle = '#333333';
      ctx.fillRect(cx - bodyWidth/4 - scaledCellSize/8, y + 2 * helmetRadius + bodyHeight + scaledCellSize/4, scaledCellSize/4, scaledCellSize/8);
      ctx.fillRect(cx + bodyWidth/4 - scaledCellSize/8, y + 2 * helmetRadius + bodyHeight + scaledCellSize/4, scaledCellSize/4, scaledCellSize/8);
    }

    function isValidMove(row, col) {
      return (
        row >= 0 && row < mazeSize &&
        col >= 0 && col < mazeSize &&
        maze[row][col] === 0
      );
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawMaze();
      drawGoal();
      drawPlayer();
    }

    function checkWin() {
      if (player.row === mazeSize - 1 && player.col === mazeSize - 1) {
        levelCount++;
        updateLevelDisplay();
        alert('You Win!');
        generateMaze();
        player.row = 0;
        player.col = 0;
        draw();
      }
    }

    function movePlayer(direction) {
      let newRow = player.row;
      let newCol = player.col;

      if (direction === 'up') newRow--;
      else if (direction === 'down') newRow++;
      else if (direction === 'left') newCol--;
      else if (direction === 'right') newCol++;

      if (isValidMove(newRow, newCol)) {
        player.row = newRow;
        player.col = newCol;
        draw();
        checkWin();
      }
    }

    // Joystick functionality
    function getTouchPos(e) {
      const rect = joystick.getBoundingClientRect();
      return {
        x: e.touches[0].clientX - rect.left,
        y: e.touches[0].clientY - rect.top
      };
    }

    function getMousePos(e) {
      const rect = joystick.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function moveJoystick(pos) {
      const dx = pos.x - joystickCenterX;
      const dy = pos.y - joystickCenterY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const maxDistance = 70;
      const threshold = 10; // Distance threshold to stop movement near center

      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        handleCenterX = joystickCenterX + maxDistance * Math.cos(angle);
        handleCenterY = joystickCenterY + maxDistance * Math.sin(angle);
      } else {
        handleCenterX = pos.x;
        handleCenterY = pos.y;
      }

      joystickHandle.style.left = `${handleCenterX - 30}px`;
      joystickHandle.style.top = `${handleCenterY - 30}px`;

      if (distance < threshold) {
        currentDirection = null; // Stop movement when near center
      } else {
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        if (angle > -45 && angle <= 45) currentDirection = 'right';
        else if (angle > 45 && angle <= 135) currentDirection = 'down';
        else if (angle > -135 && angle <= -45) currentDirection = 'up';
        else currentDirection = 'left';
      }
    }

    function resetJoystick() {
      joystickHandle.style.left = '70px';
      joystickHandle.style.top = '70px';
      currentDirection = null;
    }

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isJoystickActive = true;
      const pos = getTouchPos(e);
      moveJoystick(pos);
      moveInterval = setInterval(() => {
        if (currentDirection) {
          movePlayer(currentDirection);
        }
      }, 200); // Move every 200ms
    });

    joystick.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isJoystickActive) {
        const pos = getTouchPos(e);
        moveJoystick(pos);
      }
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      isJoystickActive = false;
      clearInterval(moveInterval);
      resetJoystick();
    });

    joystick.addEventListener('mousedown', (e) => {
      isJoystickActive = true;
      const pos = getMousePos(e);
      moveJoystick(pos);
      moveInterval = setInterval(() => {
        if (currentDirection) {
          movePlayer(currentDirection);
        }
      }, 200); // Move every 200ms
    });

    joystick.addEventListener('mousemove', (e) => {
      if (isJoystickActive) {
        const pos = getMousePos(e);
        moveJoystick(pos);
      }
    });

    joystick.addEventListener('mouseup', (e) => {
      isJoystickActive = false;
      clearInterval(moveInterval);
      resetJoystick();
    });

    joystick.addEventListener('mouseleave', (e) => {
      if (isJoystickActive) {
        isJoystickActive = false;
        clearInterval(moveInterval);
        resetJoystick();
      }
    });

    function initJoystick() {
      const rect = joystick.getBoundingClientRect();
      joystickCenterX = rect.width / 2;
      joystickCenterY = rect.height / 2;
      handleCenterX = joystickCenterX;
      handleCenterY = joystickCenterY;
    }

    window.addEventListener('load', initJoystick);
    window.addEventListener('resize', initJoystick);

    window.addEventListener('keydown', (e) => {
      if (e.key.startsWith('Arrow')) {
        e.preventDefault();
        if (e.key === 'ArrowUp') movePlayer('up');
        else if (e.key === 'ArrowDown') movePlayer('down');
        else if (e.key === 'ArrowLeft') movePlayer('left');
        else if (e.key === 'ArrowRight') movePlayer('right');
      }
    });

    sizeSelector.addEventListener('change', () => {
      mazeSize = parseInt(sizeSelector.value);
      cellSize = 400 / mazeSize;
      generateMaze();
      player.row = 0;
      player.col = 0;
      draw();
    });

    generateMaze();
    draw();
    updateLevelDisplay();
  </script>
</body>
</html>