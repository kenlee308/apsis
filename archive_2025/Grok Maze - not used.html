<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Maze Game with Level Selector</title>
 <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
 <style>
 body {
 font-family: 'Orbitron', sans-serif;
 background-color: #000;
 color: #FFF;
 text-align: center;
 }
 canvas {
 border: 2px solid #FFF;
 margin-top: 20px;
 }
 #levelDisplay, #sizeSelector {
 margin: 10px;
 }
 .controls {
 display: flex;
 justify-content: center;
 align-items: center;
 margin-top: 20px;
 gap: 10px;
 }
 .sun-button {
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 10px 20px;
 background: #333;
 color: #FFF;
 border: none;
 cursor: pointer;
 font-size: 16px;
 }
 .sun-icon {
 width: 30px;
 height: 30px;
 border-radius: 50%;
 background: radial-gradient(circle, #FFD700, #FFA500);
 margin-right: 10px;
 }
 </style>
</head>
<body>
 <div id="levelDisplay">Levels Completed: 0</div>
 <canvas id="mazeCanvas" width="400" height="400"></canvas>
 <div class="controls">
 <label for="sizeSelector">Select Maze Size:</label>
 <select id="sizeSelector">
 <option value="5">5x5</option>
 <option value="15">15x15</option>
 <option value="25">25x25</option>
 </select>
 <button class="sun-button" onclick="window.location.href='index.html'">
 <span class="sun-icon"></span>
 Back to Starbase
 </button>
 </div>
 <script>
 const canvas = document.getElementById('mazeCanvas');
 const ctx = canvas.getContext('2d');
 const sizeSelector = document.getElementById('sizeSelector');
 const levelDisplay = document.getElementById('levelDisplay');

 let mazeSize = parseInt(sizeSelector.value);
 let cellSize = 400 / mazeSize;
 let player = { row: 0, col: 0 };
 let levelCount = 0;
 let maze = [];

 function updateLevelDisplay() {
 levelDisplay.textContent = `Levels Completed: ${levelCount}`;
 }

 function generateMaze() {
 maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
 const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

 function shuffle(array) {
 for (let i = array.length - 1; i > 0; i--) {
 const j = Math.floor(Math.random() * (i + 1));
 [array[i], array[j]] = [array[j], array[i]];
 }
 return array;
 }

 function carve(row, col) {
 maze[row][col] = 0;
 const dirs = shuffle([...directions]);
 for (let [dr, dc] of dirs) {
 const newRow = row + dr;
 const newCol = col + dc;
 if (
 newRow >= 0 &&
 newRow < mazeSize &&
 newCol >= 0 &&
 newCol < mazeSize &&
 maze[newRow][newCol] === 1
 ) {
 const wallRow = row + dr / 2;
 const wallCol = col + dc / 2;
 if (
 wallRow >= 0 &&
 wallRow < mazeSize &&
 wallCol >= 0 &&
 wallCol < mazeSize
 ) {
 maze[wallRow][wallCol] = 0;
 }
 carve(newRow, newCol);
 }
 }
 }

 carve(0, 0);
 maze[0][0] = 0;
 maze[mazeSize - 1][mazeSize - 1] = 0;
 }

 function drawBackground() {
 ctx.fillStyle = 'black';
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 ctx.fillStyle = 'white';
 for (let i = 0; i < 100; i++) {
 let x = Math.random() * canvas.width;
 let y = Math.random() * canvas.height;
 ctx.fillRect(x, y, 2, 2);
 }
 }

 function drawMaze() {
 for (let row = 0; row < mazeSize; row++) {
 for (let col = 0; col < mazeSize; col++) {
 if (maze[row][col] === 1) {
 ctx.fillStyle = '#2F4F4F'; // Dark slate gray for walls
 ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
 }
 }
 }
 }

 function drawGoal() {
 ctx.fillStyle = 'yellow';
 ctx.beginPath();
 ctx.arc(
 (mazeSize - 1) * cellSize + cellSize / 2,
 (mazeSize - 1) * cellSize + cellSize / 2,
 cellSize / 3,
 0,
 2 * Math.PI
 );
 ctx.fill();
 }

 function drawPlayer() {
 ctx.fillStyle = '#FF4500'; // Orange red for spaceship
 ctx.beginPath();
 ctx.moveTo(player.col * cellSize + cellSize / 2, player.row * cellSize + cellSize / 4);
 ctx.lineTo(player.col * cellSize + cellSize / 4, player.row * cellSize + (3 * cellSize) / 4);
 ctx.lineTo(player.col * cellSize + (3 * cellSize) / 4, player.row * cellSize + (3 * cellSize) / 4);
 ctx.closePath();
 ctx.fill();
 }

 function isValidMove(row, col) {
 return (
 row >= 0 &&
 row < mazeSize &&
 col >= 0 &&
 col < mazeSize &&
 maze[row][col] === 0
 );
 }

 function draw() {
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 drawBackground();
 drawMaze();
 drawGoal();
 drawPlayer();
 }

 function checkWin() {
 if (player.row === mazeSize - 1 && player.col === mazeSize - 1) {
 levelCount++;
 updateLevelDisplay();
 alert('You Win!');
 generateMaze();
 player.row = 0;
 player.col = 0;
 draw();
 }
 }

 window.addEventListener('keydown', (e) => {
 if (e.key.startsWith('Arrow')) {
 e.preventDefault();
 let newRow = player.row;
 let newCol = player.col;

 if (e.key === 'ArrowUp') newRow--;
 else if (e.key === 'ArrowDown') newRow++;
 else if (e.key === 'ArrowLeft') newCol--;
 else if (e.key === 'ArrowRight') newCol++;

 if (isValidMove(newRow, newCol)) {
 player.row = newRow;
 player.col = newCol;
 draw();
 checkWin();
 }
 }
 });

 sizeSelector.addEventListener('change', () => {
 mazeSize = parseInt(sizeSelector.value);
 cellSize = 400 / mazeSize;
 generateMaze();
 player.row = 0;
 player.col = 0;
 draw();
 });

 generateMaze();
 draw();
 updateLevelDisplay();
 </script>
</body>
</html>